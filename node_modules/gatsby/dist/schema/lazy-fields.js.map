{"version":3,"sources":["../../src/schema/lazy-fields.js"],"names":["_","require","GraphQLList","GraphQLObjectType","typeFields","Map","contains","filters","fieldType","some","fieldFilter","fieldName","storedFields","get","name","has","gqlFieldType","getFields","type","elemMatch","ofType","add","typeName","set","Set","module","exports"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,CAAC,GAAGC,OAAO,CAAE,QAAF,CAAjB;;iBAC2CA,OAAO,CAAE,SAAF,C;MAA1CC,W,YAAAA,W;MAAaC,iB,YAAAA,iB,EAErB;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAU,GAAG,IAAIC,GAAJ,EAAnB;;AAEA,SAASC,QAAT,CAAkBC,OAAlB,EAA2BC,SAA3B,EAAsC;AACpC,SAAOR,CAAC,CAACS,IAAF,CAAOF,OAAP,EAAgB,CAACG,WAAD,EAAcC,SAAd,KAA4B;AACjD;AACA;AACA,UAAMC,YAAY,GAAGR,UAAU,CAACS,GAAX,CAAeL,SAAS,CAACM,IAAzB,CAArB;;AACA,QAAIF,YAAY,IAAIA,YAAY,CAACG,GAAb,CAAiBJ,SAAjB,CAApB,EAAiD;AAC/C,aAAO,IAAP;AACD,KAFD,MAEO;AAAA;;AACL;AACA;AACA;AACA;AACA,YAAMK,YAAY,4BAAGR,SAAS,CAACS,SAAV,GAAsBN,SAAtB,CAAH,0DAAG,sBAAkCO,IAAvD;;AACA,UAAIF,YAAJ,EAAkB;AAChB,YAAIA,YAAY,YAAYd,WAAxB,IAAuCQ,WAAW,CAACS,SAAvD,EAAkE;AAChE,iBAAOb,QAAQ,CAACI,WAAW,CAACS,SAAb,EAAwBH,YAAY,CAACI,MAArC,CAAf;AACD,SAFD,MAEO,IAAIJ,YAAY,YAAYb,iBAA5B,EAA+C;AACpD,iBAAOG,QAAQ,CAACI,WAAD,EAAcM,YAAd,CAAf;AACD;AACF;AACF;;AACD,WAAO,KAAP;AACD,GArBM,CAAP;AAsBD;;AAED,SAASK,GAAT,CAAaC,QAAb,EAAuBX,SAAvB,EAAkC;AAChC,MAAIP,UAAU,CAACS,GAAX,CAAeS,QAAf,CAAJ,EAA8B;AAC5BlB,IAAAA,UAAU,CAACS,GAAX,CAAeS,QAAf,EAAyBD,GAAzB,CAA6BV,SAA7B;AACD,GAFD,MAEO;AACLP,IAAAA,UAAU,CAACmB,GAAX,CAAeD,QAAf,EAAyB,IAAIE,GAAJ,CAAQ,CAACb,SAAD,CAAR,CAAzB;AACD;AACF;;AAEDc,MAAM,CAACC,OAAP,GAAiB;AACfpB,EAAAA,QADe;AAEfe,EAAAA;AAFe,CAAjB","sourcesContent":["// A normal Graphql field resolver will accept a node as an argument\n// and return a field from that node. Whereas a lazy field will need\n// to perform some side effects or non-deterministic behavior to\n// return its value. Therefore, when a query filter includes a lazy\n// field, we need to evaluate the field resolvers on all nodes before\n// running the query. Examples of lazy fields include:\n//\n// - a markdown `wordcount` field (lazily calculates word count on its\n//   content)\n// - image sharp processing field (lazily generates optimized images)\n//\n// Lazy fields are declared using the exported `add` function. This\n// should be done during schema generation when fields are being\n// created. Then at query time, we can use the exported `contains`\n// function to figure out if a type/field pair is lazy, and therefore\n// use sift for querying instead of loki\n\nconst _ = require(`lodash`)\nconst { GraphQLList, GraphQLObjectType } = require(`graphql`)\n\n// Note: fields are never deleted from here. So a long running\n// `develop` session, where nodes are being deleted might mean that\n// fields exist here that aren't on any DB nodes anymore. This isn't\n// ideal, BUT, the worst case is that queries will be executed by\n// sift, rather than loki, so not a big deal\nconst typeFields = new Map()\n\nfunction contains(filters, fieldType) {\n  return _.some(filters, (fieldFilter, fieldName) => {\n    // If a field has been previously flagged as a lazy field, then\n    // return true\n    const storedFields = typeFields.get(fieldType.name)\n    if (storedFields && storedFields.has(fieldName)) {\n      return true\n    } else {\n      // Otherwise, the filter field might be an array of linked\n      // nodes, in which case we might filter via an elemMatch\n      // field. Or, it might be a nested linked object. In either\n      // case, we recurse\n      const gqlFieldType = fieldType.getFields()[fieldName]?.type\n      if (gqlFieldType) {\n        if (gqlFieldType instanceof GraphQLList && fieldFilter.elemMatch) {\n          return contains(fieldFilter.elemMatch, gqlFieldType.ofType)\n        } else if (gqlFieldType instanceof GraphQLObjectType) {\n          return contains(fieldFilter, gqlFieldType)\n        }\n      }\n    }\n    return false\n  })\n}\n\nfunction add(typeName, fieldName) {\n  if (typeFields.get(typeName)) {\n    typeFields.get(typeName).add(fieldName)\n  } else {\n    typeFields.set(typeName, new Set([fieldName]))\n  }\n}\n\nmodule.exports = {\n  contains,\n  add,\n}\n"],"file":"lazy-fields.js"}