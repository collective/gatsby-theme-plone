{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["sift","require","_","prepareRegex","Promise","trackInlineObjectsInRootNode","getNode","getNodesByType","store","enhancedNodeCache","Map","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","siftifyArgs","object","newObject","each","v","k","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","filter","Object","keys","reduce","acc","key","value","parseFilter","siftArgs","fieldsToSift","push","isEqId","firstOnly","length","awaitSiftField","fields","field","resolve","fieldName","undefined","resolveRecursive","siftFieldsObj","gqFields","all","map","then","innerSift","innerGqConfig","isObject","type","isFunction","getFields","isArray","ofType","item","resolvedFields","myNode","forEach","resolveNodes","nodes","typeName","gqlFields","getState","resolvedNodesCache","nodesCacheKey","nodesLength","has","get","cacheKey","enhancedNodeGenerationPromise","resolvedNode","set","resolvedNodes","dispatch","payload","handleFirst","index","isEmpty","indexOf","$and","handleMany","sort","result","convertedFields","replace","orderBy","order","module","exports","queryArgs","gqlType","name"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`../db/node-tracking`)\nconst { getNode, getNodesByType } = require(`../db/nodes`)\nconst { store } = require(`.`)\n\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nfunction siftifyArgs(object) {\n  const newObject = {}\n  _.each(object, (v, k) => {\n    if (_.isPlainObject(v)) {\n      if (k === `elemMatch`) {\n        k = `$elemMatch`\n      }\n      newObject[k] = siftifyArgs(v)\n    } else {\n      // Compile regex first.\n      if (k === `regex`) {\n        newObject[`$regex`] = prepareRegex(v)\n      } else if (k === `glob`) {\n        const Minimatch = require(`minimatch`).Minimatch\n        const mm = new Minimatch(v)\n        newObject[`$regex`] = mm.makeRe()\n      } else {\n        newObject[`$${k}`] = v\n      }\n    }\n  })\n  return newObject\n}\n\n// Build an object that excludes the innermost leafs,\n// this avoids including { eq: x } when resolving fields.\nconst extractFieldsToSift = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    let value = filter[key]\n    let k = Object.keys(value)[0]\n    let v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? extractFieldsToSift(v) : extractFieldsToSift(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\n/**\n * Parse filter and returns an object with two fields:\n * - siftArgs: the filter in a format that sift understands\n * - fieldsToSift: filter with operate leaves (e.g { eq: 3 })\n *   removed. Used later to resolve all filter fields\n */\nfunction parseFilter(filter) {\n  const siftArgs = []\n  let fieldsToSift = {}\n  if (filter) {\n    _.each(filter, (v, k) => {\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n    })\n    fieldsToSift = extractFieldsToSift(filter)\n  }\n  return { siftArgs, fieldsToSift }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Resolve nodes\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(firstOnly, fieldsToSift, siftArgs) {\n  return (\n    firstOnly &&\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id` &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(\n      node,\n      {},\n      {},\n      {\n        fieldName: k,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n// Resolves every field used in the node.\nfunction resolveRecursive(node, siftFieldsObj, gqFields) {\n  return Promise.all(\n    _.keys(siftFieldsObj).map(k =>\n      Promise.resolve(awaitSiftField(gqFields, node, k))\n        .then(v => {\n          const innerSift = siftFieldsObj[k]\n          const innerGqConfig = gqFields[k]\n          if (\n            _.isObject(innerSift) &&\n            v != null &&\n            innerGqConfig &&\n            innerGqConfig.type\n          ) {\n            if (_.isFunction(innerGqConfig.type.getFields)) {\n              // this is single object\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else if (\n              _.isArray(v) &&\n              innerGqConfig.type.ofType &&\n              _.isFunction(innerGqConfig.type.ofType.getFields)\n            ) {\n              // this is array\n              return Promise.all(\n                v.map(item =>\n                  resolveRecursive(\n                    item,\n                    innerSift,\n                    innerGqConfig.type.ofType.getFields()\n                  )\n                )\n              )\n            }\n          }\n\n          return v\n        })\n        .then(v => [k, v])\n    )\n  ).then(resolvedFields => {\n    const myNode = {\n      ...node,\n    }\n    resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n    return myNode\n  })\n}\n\nfunction resolveNodes(nodes, typeName, firstOnly, fieldsToSift, gqlFields) {\n  const { resolvedNodesCache } = store.getState()\n  const nodesCacheKey = JSON.stringify({\n    // typeName + count being the same is a pretty good\n    // indication that the nodes are the same.\n    typeName,\n    firstOnly,\n    nodesLength: nodes.length,\n    ...fieldsToSift,\n  })\n  if (resolvedNodesCache.has(nodesCacheKey)) {\n    return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n  } else {\n    return Promise.all(\n      nodes.map(node => {\n        const cacheKey = enhancedNodeCacheId({\n          node,\n          args: fieldsToSift,\n        })\n        if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n          return Promise.resolve(enhancedNodeCache.get(cacheKey))\n        } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n          return enhancedNodePromiseCache.get(cacheKey)\n        }\n\n        const enhancedNodeGenerationPromise = new Promise(resolve => {\n          resolveRecursive(node, fieldsToSift, gqlFields).then(resolvedNode => {\n            trackInlineObjectsInRootNode(resolvedNode)\n            if (cacheKey) {\n              enhancedNodeCache.set(cacheKey, resolvedNode)\n            }\n            resolve(resolvedNode)\n          })\n        })\n        enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n        return enhancedNodeGenerationPromise\n      })\n    ).then(resolvedNodes => {\n      store.dispatch({\n        type: `SET_RESOLVED_NODES`,\n        payload: {\n          key: nodesCacheKey,\n          nodes: resolvedNodes,\n        },\n      })\n      return resolvedNodes\n    })\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction handleFirst(siftArgs, nodes) {\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : sift.indexOf(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : sift(\n        {\n          $and: siftArgs,\n        },\n        nodes\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort) {\n    // create functions that return the item to compare on\n    // uses _.get so nested fields can be retrieved\n    const convertedFields = sort.fields\n      .map(field => field.replace(/___/g, `.`))\n      .map(field => v => _.get(v, field))\n\n    result = _.orderBy(result, convertedFields, sort.order)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nmodule.exports = (args: Object) => {\n  const { queryArgs, gqlType, firstOnly = false } = args\n\n  // If nodes weren't provided, then load them from the DB\n  const nodes = args.nodes || getNodesByType(gqlType.name)\n\n  const { siftArgs, fieldsToSift } = parseFilter(queryArgs.filter)\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(firstOnly, fieldsToSift, siftArgs)) {\n    const node = getNode(siftArgs[0].id[`$eq`])\n\n    if (!node || (node.internal && node.internal.type !== gqlType.name)) {\n      return []\n    }\n\n    return resolveRecursive(node, fieldsToSift, gqlType.getFields()).then(\n      node => (node ? [node] : [])\n    )\n  }\n\n  return resolveNodes(\n    nodes,\n    gqlType.name,\n    firstOnly,\n    fieldsToSift,\n    gqlType.getFields()\n  ).then(resolvedNodes => {\n    if (firstOnly) {\n      return handleFirst(siftArgs, resolvedNodes)\n    } else {\n      return handleMany(siftArgs, resolvedNodes, queryArgs.sort)\n    }\n  })\n}\n"],"file":"run-sift.js"}